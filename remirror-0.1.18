#!/bin/bash
#
# Remirror: rank mirrors for Antergos and Arch.
# Similar idea to reflector or reflector-antergos.

ARCH=x86_64
REPO_ANTERGOS=antergos
REPO_ARCH=core             # use this repo for ranking Arch mirrors

echo2()
{
    if [ "$QUIET" = "false" ] ; then
        echo "$@" >&2
    fi
}
debug()
{
    if [ "$DEBUG" = "true" ] ; then
        echo "DEBUG: " "${FUNCNAME[1]}" ": " "$@" >&2
    fi
}

printf2()
{
    if [ "$QUIET" = "false" ] ; then
        printf "$@" >&2
    fi
}
Error()
{
    local arg
    case "$1" in
        -n) arg="$1" ; shift ;;
    esac
    echo $arg "Error: " "$@" >&2

    exit 1     ###################   !!!!!!
}

GetLatestList()
{
    local os="$1"
    local latest_mirrors_file=/tmp/latest-mirrors.tmp
    local urlbase
    local maxtime=$REFERENCE_MAX_SEC
    local repo arch=$ARCH           # antergos
    local tmpfile=/tmp/aml-tmp.tmp  # antergos
    local file                      # antergos
    local ret=0

    case "$os" in
        Arch)
            urlbase=https://www.archlinux.org/mirrorlist/all/
            Curl $urlbase "$latest_mirrors_file" --max-time $maxtime
            if [ $? -ne 0 ] ; then
                Error "unable to fetch official mirrorlist from '$urlbase'"
            fi
            ;;
        Antergos)
            repo=$REPO_ANTERGOS

            urlbase=https://repo.antergos.info/$repo/$arch

            Curl $urlbase/ $tmpfile --max-time $maxtime   # find out the containing file
            if [ $? -ne 0 ] ; then
                Error "unable to fetch official antergos-mirrorlist info from '$urlbase/'"
            fi

            file=$(cat $tmpfile | sed 's|<|\n<|g' | grep antergos-mirrorlist |
                       grep -v "sig" | sed 's|^.*\(antergos-mirrorlist.*xz\)$|\1|')
            rm -f $tmpfile

            Curl $urlbase/$file $tmpfile --max-time $maxtime  # fetch the containing file first
            if [ $? -ne 0 ] ; then
                Error "unable to fetch official antergos-mirrorlist from '$urlbase/$file'"
            fi

            pushd /tmp >/dev/null
                tar xf $tmpfile >/dev/null 2>&1
                if [ -f etc/pacman.d/antergos-mirrorlist ] ; then
                    cp -f etc/pacman.d/antergos-mirrorlist "$latest_mirrors_file"
                fi
                rm -f $tmpfile
                rm -rf etc
            popd >/dev/null
            ;;
        *)
            Error "invalid os '$os'."
            ;;
    esac
    echo "$latest_mirrors_file"
}

ShowMirrorResult()
{
    local country="$1"
    local dltime="$2"
    local result="$3"
    local mirror="$4"

    printf2 "   %.3f %-20s %s\n" "$dltime" "$result" "$mirror"
}
ShowMirrorCountry()
{
    local country="$1"
    local protocol="$2"

    #echo2 "$country [$protocol]"
    echo2 "$country"
}

MirrorsOfCountry()
{
    local country="$1"
    local protocol="$2"
    local latest_mirrors_file="$3"
    local os="$4"
    local tofile="$5"
    local antergos_automated=no

    if [ "$os" = "Antergos" ] ; then
        case "$country" in
            Automated*)
                antergos_automated=yes
                ;;
        esac
    fi
    if [ "$antergos_automated" = "yes" ] ; then
        sed -n '/^# '"$country"'/,/^# Manual Mirror Selection$/ p' $latest_mirrors_file \
            | grep -v "Manual Mirror Selection" \
            | grep "^[#]*Server = " | awk '{print $NF}' > "$tofile"
        # explicitly grepping out "Manual Mirror Selection" is not really required...
    else
        sed -n '/^#[#]* '"$country"'/,/^$/ p' $latest_mirrors_file \
            | grep "^[#]*Server = " | awk '{print $NF}' > "$tofile"
    fi

    # show country name if mirrors with given protocol are found
    if [ "$(grep "$protocol:" "$tofile")" != "" ] ; then
        ShowMirrorCountry "$country" "$protocol"
    fi
}

Countries()
{
    local latest_mirrors_file="$1"
    local tofile="$2"

    if [ "$tofile" = "" ] ; then
        Error "$FUNCNAME: no output file."
    fi

    grep "^#[#]* " $latest_mirrors_file \
        | grep -E -v "Arch Linux|Generated on|Antergos Repository|Manual Mirror" \
        | sed 's|^#[#]* ||' > "$tofile"
}

Curl()
{
    local url="$1"
    local out="$2"

    shift 2
    local maxtime=$MIRROR_MAX_SEC   # for mirrors!

    local cmd="curl --location --remote-time --silent --max-time $maxtime"

    $cmd "$url" --output "$out" "$@"
}

RankMirror()
{
    local os="$1"
    local mirror="$2"
    local country="$3"
    local outfile="$4"
    local protocol="$5"

    # handle constructor and destructor!
    case "$1" in
        -i|-d) os="$2" ;;
    esac

    local repo arch=$ARCH
    local refurl

    case "$os" in
        Arch)
            repo=$REPO_ARCH
            refurl=https://mirrors.edge.kernel.org/archlinux/$repo/os/$arch/$repo.files.tar.gz
            # TODO: find the best reference site ?
            ;;
        Antergos)
            repo=$REPO_ANTERGOS
            refurl=https://repo.antergos.info/$repo/$arch/antergos.files.tar.gz
            ;;
    esac

    local file=$(basename "$refurl")
    local reffile="/tmp/$file.ref"         # reference file (master)
    local mirrorfile="/tmp/$file.tmp"      # downloaded from a mirror, compare to $reffile

    case "$1" in
        -i)
            rm -f "$reffile"  # make sure no old leftovers exist
            Curl "$refurl" "$reffile" --max-time $REFERENCE_MAX_SEC
            if [ $? -ne 0 ] ; then
                Error "cannot download reference file from '$refurl'."
            fi
            return
            ;;
        -d)
            rm -f "$reffile"
            return
            ;;
    esac

    # Here's the actual ranking of a mirror taking place.

    local url dltime res
    local mirror_substituted=$(echo "$mirror" |
                                   sed -e 's|/\$arch$|/'$arch'|' -e 's|/\$repo/|/'$repo'/|')
    url="$mirror_substituted/$file"

    rm -f $mirrorfile  # make sure no old leftovers exist
    dltime=$(Curl "$url" "$mirrorfile" --write-out "%{time_total}")
    res=$?
    dltime=$(printf "%.3f" "$dltime")                                   # use 3 decimals

    if [ $res -eq 0 ] ; then
        cmp "$mirrorfile" "$reffile" >/dev/null 2>&1
        if [ $? -eq 0 ] ; then
            ShowMirrorResult "$country" "$dltime" "(OK)" "$mirror"
            echo "$dltime|$country|$mirror" >> "$outfile"
        else
            ShowMirrorResult "$country" "$dltime" "(contents differ)" "$mirror"
        fi
    else
        ShowMirrorResult "$country" "$dltime" "(download failed)" "$mirror"
    fi
    rm -f $mirrorfile
}

OsName()
{
    case "$OPERATING_SYSTEM" in             # note: only one os at a time!
        os_antergos|antergos|Antergos)
            echo "Antergos"
            ;;
        os_arch|arch|Arch)
            echo "Arch"
            ;;
        *)
            Error "unsupported operating system name '$OPERATING_SYSTEM'"
            ;;
    esac
}
ListFileName()
{
    case "$OPERATING_SYSTEM" in
        Antergos) echo "/etc/pacman.d/antergos-mirrorlist" ;;
        Arch)     echo "/etc/pacman.d/mirrorlist" ;;
    esac
}

CmdArgs()
{
    # Show (echo) command and args as user should write them
    # (note that some args may include spaces).

    local arg arg2
    local result
    
    for arg in "$@"
    do
        if [ "$(echo "$arg" | tr ' ' '_')" != "$arg" ] ; then  # tr because sed doesn't work?
            arg2="\"$arg\""  # arg contains white spaces
        else
            arg2="$arg"
        fi
        if [ -z "$result" ] ; then
            result="$arg2"
        else
            result+=" $arg2"
        fi
    done
    echo "$result"
}

RunCmds()
{
    local prompt="$1"
    local cmds="$2"

    if [ $(id -u) -eq 0 ] ; then
        eval $cmds
    else
        echo2 -n "$prompt"
        sudo bash -c "$cmds"
    fi
}

RankThem()
{
    local os=$OPERATING_SYSTEM              # Antergos or Arch
    local list=$(ListFileName)              # antergos-mirrorlist or mirrorlist
    local mirror mirrors
    local country countries
    local tmpoutfile=/tmp/foobar-tmp.tmp
    local latest_mirrors_file
    local rank result dltime
    local outfile outfiles
    local xx xx2
    local prot
    local osname=$(OsName)

    if [ ! -f $list ] ; then
        Error "Mirror list file '$list' does not exist"
    fi

    echo2 "Ranking $osname mirrors ..."

    latest_mirrors_file=$(GetLatestList $os)
    if [ ! -f "$latest_mirrors_file" ] ; then
        Error "no latest mirrors for $os"
    fi

    RankMirror -i $os

    Countries "$latest_mirrors_file" "$tmpoutfile"
    readarray -t countries < "$tmpoutfile"          # contains names that may include spaces

    for prot in "${PROTOCOLS[@]}"
    do
        outfile=/tmp/ranked-"$prot"-"$os".$prot
        rm -f "$outfile"

        for country in "${countries[@]}"
        do
            if [ "$INCLUDED_COUNTRIES" != "" ] ; then
                for xx in "${INCLUDED_COUNTRIES[@]}" ; do
                    xx2="${xx//_/ }"                          # xx may have '_' instead of ' '
                    if [ "$country" = "$xx2" ] ; then
                        break
                    fi
                done
                if [ "$country" != "$xx2" ] ; then
                    continue
                fi
            fi

            MirrorsOfCountry "$country" $prot $latest_mirrors_file $os $tmpoutfile
            readarray -t mirrors < $tmpoutfile

            for mirror in "${mirrors[@]}"
            do
                # check that requested protocol is available for this mirror in the mirrorlist
                case "$prot" in
                    https) test "${mirror::6}" != "https:" && continue ;;
                    http)  test "${mirror::5}" != "http:"  && continue ;;
                esac

                RankMirror "$os" "$mirror" "$country" "$outfile" "$prot"
            done
        done
        if [ -f "$outfile" ] ; then
            sort "$outfile" > "$outfile".tmp
            mv -f "$outfile".tmp "$outfile"
            outfiles+=("$outfile")
        fi
    done

    outfile=/tmp/ranked-$os.txt

    for xx in "${outfiles[@]}"
    do
        case "$xx" in
            *.http)  printf "%s\n\n" "### HTTP:"  >> "$outfile" ;;
            *.https) printf "%s\n\n" "### HTTPS:" >> "$outfile" ;;
        esac
        cat "$xx" >> "$outfile"
        echo "" >> "$outfile"
        rm -f "$xx"
    done

    if [ -f "$outfile" ] ; then
        cat "$outfile" \
            | sed 's/^\(.*\)|\(.*\)|\(.*\)$/### \1 \2:\nServer = \3/' \
                  > "$outfile".tmp

        # Now mirrors are ordered in $outfile.tmp.

        echo "### Ranked mirrors for $os."                > "$outfile"
        echo "###"                                       >> "$outfile"
        echo "### Date of generation: $(date)"           >> "$outfile"
        echo "### Command: $(CmdArgs "$(basename $0)" "${COMMAND_ARGS[@]}")" >> "$outfile"
        echo "###"                                       >> "$outfile"
        echo ""                                          >> "$outfile"

        cat "$outfile".tmp >> "$outfile"
        rm -f "$outfile".tmp

        if [ "$APPEND_OFFICIAL" = "yes" ] ; then
            echo "" >> "$outfile"
            echo "##### Official mirrors file: #######" >> "$outfile"
            echo "" >> "$outfile"
            cat $latest_mirrors_file >> "$outfile"
        fi

        local list=$(ListFileName)
        local prompt="Saving $osname mirror list, root permissions required. "

        case "$SAVE_LIST" in
            backup)
                local oldlist="$list-$(date +%Y%m%d-%H%M%S).backup"
                RunCmds "$prompt" "mv $list $oldlist ; cp $outfile $list"
                if [ $? -eq 0 ] ; then
                    printf2 "New mirror list saved to file %s.\nFormer list moved to file %s.\n" \
                            "$list" "$oldlist"
                else
                    echo2 "Nothing saved."
                fi
                ;;
            yes)
                RunCmds "$prompt" "cp $outfile $list"
                if [ $? -eq 0 ] ; then
                    echo2 "New mirror list saved to file $list."
                else
                    echo2 "Nothing saved."
                fi
                ;;
            no)
                cat "$outfile"         # show the result in standard output
                ;;
        esac
        rm -f "$outfile"
    else
        echo2 "Warning: no rankable mirrors found!"
    fi

    RankMirror -d $os

    rm -f $latest_mirrors_file $tmpoutfile
}

Opt2Val()
{
    echo "$1" | sed 's|^-.*=||'
}
Opt2ValInt()
{
    local arg="$1"
    local int=$(Opt2Val "$arg")
    if [ "$(CheckInt "$int")" = "fail" ] ; then
        Usage
        Error "'$int' is not an integer in '$arg'."
    fi
    echo "$int"
}
CheckInt()
{
    local int="$1"
    if [ "$(echo "$int" | sed 's|[0-9]*||')" = "" ] ; then
        echo ok
    else
        echo fail
    fi
}
arr2list()
{
    local xx
    local out

    for xx in "$@"
    do
        if [ "$out" = "" ] ; then
            out="$xx"
        else
            out+=",$xx"
        fi
    done
    echo "$out"
}

Usage()
{
    echo2 "========================================================================="
    echo2 "Antergos and Arch mirror ranking."
    echo2 ""
    echo2 "Generates ranked official mirror lists to standard output."
    echo2 "The generated lists are suitable for:"
    echo2 "    /etc/pacman.d/antergos-mirrorlist    (option: --os=Antergos)"
    echo2 "    /etc/pacman.d/mirrorlist             (option: --os=Arch)"
    echo2 ""
    echo2 "Note that only up-to-date mirrors are ranked and added to the list."
    echo2 "Other mirrors can be added with option '--of'."
    echo2 "========================================================================="
    echo2 ""
    echo2 "Usage: $(basename $0) [options]"
    echo2 "Options:"
    echo2 "  --os=X            Operating system name. Supported values: Antergos, Arch, both."
    echo2 "                    X is $OPERATING_SYSTEM_DEFAULT by default."
    echo2 "  --c=X             Countries to include. This option could be used e.g. for ranking"
    echo2 "                    only nearby countries for efficiency."
    echo2 "                    X is a comma separated list of country names."
    echo2 "                    Note: use full country names (including spaces), such as"
    echo2 "                    \"Czech Republic\" or \"Hong Kong\"."
    echo2 "                    Remember to use quotes if spaces are included in the country name."
    echo2 "                    By default, all supported countries are ranked."
    echo2 "                    NOTE: with --os=both, don't use --c=X but the next two options."
    echo2 "  --c-antergos=X    Like --c=X but used only with --os=both."
    echo2 "  --c-arch=X        Like --c=X but used only with --os=both."
    echo2 "  --p=X             Protocols to include. X is a comma separated list of protocol names"
    echo2 "                    (supported: https and http). Note that the order is significant."
    echo2 "                    X is \"$(arr2list "${PROTOCOLS_DEFAULT[@]}")\" by default."
    echo2 "  --tm=X            Max time (in seconds) to rank one mirror before timeout."
    echo2 "                    X is $MIRROR_MAX_SEC_DEFAULT by default."
    echo2 "  --tr=X            Max time (in seconds) for fetching the master reference file"
    echo2 "                    before timeout. X is $REFERENCE_MAX_SEC_DEFAULT by default."
    echo2 "  --save=X          Saves the ranked mirror list to /etc/pacman.d after backing up the old list."
    echo2 "                    Note: root permissions are required for saving."
    echo2 "                    X=no: don't save (default), X=yes: save but no backup, X=backup: save and backup old."
    echo2 "  --of              Add official mirror list to the end (for reference)."
    echo2 "  --quiet           Quiet mode, less screen output."
    if [ "$FUNCNEST" = "50" ] ; then
    echo2 "  --debug           Show some debug info!"
    fi
    echo2 "  -h"
    echo2 "  --help            This help."
    echo2 ""
    echo2 "Examples:"
    echo2 "     # use only mirrors from the selected countries:"
    echo2 "     remirror --save=yes --os=both --c-antergos=France,Germany --c-arch=Germany,Netherlands"
    echo2 ""
    echo2 "     # rank all known mirrors (slow!), backup the former lists, and save the new results:"
    echo2 "     remirror --save=backup --os=both"
    echo2 ""
    echo2 "     # rank mirrors from selected countries, and save the new results:"
    echo2 "     remirror --save=yes --c=France,Germany,Netherlands"
    echo2 ""
    echo2 "     # rank all known mirrors (slow!), and save the new results:"
    echo2 "     remirror --save=yes"
}

Main()
{
    local tmpoutfile=/tmp/foobar-tmp.tmp
    local xx

    # default values
    REFERENCE_MAX_SEC_DEFAULT=10                 # max check time (seconds) for the reference file
    MIRROR_MAX_SEC_DEFAULT=5                     # max check time (seconds) for a mirror
    PROTOCOLS_DEFAULT=(https http)               # included protocols
    OPERATING_SYSTEM_DEFAULT=both                # default os

    # actual values
    REFERENCE_MAX_SEC=$REFERENCE_MAX_SEC_DEFAULT        # max check time (seconds) for the reference file
    MIRROR_MAX_SEC=$MIRROR_MAX_SEC_DEFAULT              # max check time (seconds) for a mirror
    PROTOCOLS=("${PROTOCOLS_DEFAULT[@]}")               # included protocols
    OPERATING_SYSTEM=$OPERATING_SYSTEM_DEFAULT          # selects mirrorlist (antergos-mirrorlist or mirrorlist) for updating

    QUIET=false                 # verbosity
    DEBUG=false                 # for debugging, did you guess it?
    APPEND_OFFICIAL=no          # append official mirrorlist or not
    SAVE_LIST=no                # save the mirrorlist to /etc/pacman.d; saving requires root permissions

    local countries_antergos countries_arch

    COMMAND_ARGS=("$@")
    
    # Handle options:
    local arg
    for arg in "$@"
    do
        case "$arg" in
            --os=*)
                OPERATING_SYSTEM="$(Opt2Val "$arg")"
                # check validity
                case "$OPERATING_SYSTEM" in
                    os_antergos|antergos|Antergos)
                        OPERATING_SYSTEM=Antergos
                        ;;
                    os_arch|arch|Arch)
                        OPERATING_SYSTEM=Arch
                        ;;
                    both|Both)
                        # handle this special case below
                        OPERATING_SYSTEM=both
                        ;;
                    *)
                        Usage
                        Error "unsupported operating system name '$OPERATING_SYSTEM'"
                        ;;
                esac
                ;;
            --c=*)         # comma separated list of countries
                echo "$(Opt2Val "$arg")" | tr ',' '\n' > $tmpoutfile
                readarray -t INCLUDED_COUNTRIES < $tmpoutfile
                rm -f $tmpoutfile
                if [ "$INCLUDED_COUNTRIES" = "" ] ; then
                    Usage
                    Error "unknown value in '$arg'"
                fi
                ;;
            --c-antergos=*)         # comma separated list of countries
                echo "$(Opt2Val "$arg")" | tr ',' '\n' > $tmpoutfile
                readarray -t countries_antergos < $tmpoutfile
                rm -f $tmpoutfile
                if [ "$countries_antergos" = "" ] ; then
                    Usage
                    Error "unknown value in '$arg'"
                fi
                ;;
            --c-arch=*)         # comma separated list of countries
                echo "$(Opt2Val "$arg")" | tr ',' '\n' > $tmpoutfile
                readarray -t countries_arch < $tmpoutfile
                rm -f $tmpoutfile
                if [ "$countries_arch" = "" ] ; then
                    Usage
                    Error "unknown value in '$arg'"
                fi
                ;;
            --p=*)         # comma separated list of protocols (http, https)
                echo "$(Opt2Val "$arg")" | tr ',' '\n' > $tmpoutfile
                readarray -t PROTOCOLS < $tmpoutfile
                rm -f $tmpoutfile

                if [ "$PROTOCOLS" = "" ] ; then
                    Usage
                    Error "unknown value in '$arg'"
                fi
                for xx in "${PROTOCOLS[@]}" ; do
                    case "$xx" in
                        http|https) ;;
                        *) Usage ; Error "protocol '$xx' in '$arg' not supported." ;;
                    esac
                done
                ;;
            --tm=*)
                MIRROR_MAX_SEC=$(Opt2ValInt "$arg")
                ;;
            --tr=*)
                REFERENCE_MAX_SEC=$(Opt2ValInt "$arg")
                ;;
            --save=*)
                SAVE_LIST=$(Opt2Val "$arg")
                case "$SAVE_LIST" in
                    no|yes|backup) ;;
                    *) Usage ; Error "value '$SAVE_LIST' in '$arg' not supported." ;;
                esac
                ;;
            -of|--of)
                APPEND_OFFICIAL=yes
                ;;
            -quiet|--quiet)
                QUIET=true
                ;;
            -debug|--debug)
                DEBUG=true
                ;;
            -h|--h|-help|--help)
                Usage
                return
                ;;
            *)
                Usage
                Error "unsupported option '$arg'"
                ;;
        esac
    done

    # option --c-<os>= takes precedence over old --c=
    # empty country list means all known countries

    case "$OPERATING_SYSTEM" in
        both)
            OPERATING_SYSTEM=Antergos
            if [ -n "$countries_antergos" ] ; then
                INCLUDED_COUNTRIES=("${countries_antergos[@]}")
            fi
            RankThem
            
            OPERATING_SYSTEM=Arch
            if [ -n "$countries_arch" ] ; then
                INCLUDED_COUNTRIES=("${countries_arch[@]}")
            fi
            RankThem
            ;;
        Antergos)
            if [ -n "$countries_antergos" ] ; then
                INCLUDED_COUNTRIES=("${countries_antergos[@]}")
            fi
            RankThem
            ;;
        Arch)
            if [ -n "$countries_arch" ] ; then
                INCLUDED_COUNTRIES=("${countries_arch[@]}")
            fi
            RankThem
            ;;
    esac
}

Main "$@"

_RemoveBashCompletionLeftovers()
{
    # Workaround: remove stuff that remirror-bash-completion may have left there.
    local osfile=/tmp/remirror-os.tmp
    rm -f $osfile
}
_RemoveBashCompletionLeftovers
